#summary Public function reference on NetworkFacade(English)

= Initialization methods =

  * Note
    * Initialization methods aren't thread safe. It should be called only before start service.

== Create ==

  * Description
    * Decide event model(Proactor/Reactor)
  * Note
    * On Windows, Proactor is the best choice for performance. On Linux, Reactor is the one.

== Add Acceptor ==

  * Description
    * Prepare for Listen 
    * Add an accept port
  * Parameter
    * acceptIp : In case you want to accept only specific ip. Otherwise assign NULL.
    * port : listen port
    * queueId : It must be same as [FunctionReferenceEng#Pop_Message PopMessage] (or [FunctionReferenceEng#Pop_All_Message PopAllMessage]) queueId parameter.
    * receiveBufferSize : The maximum receive buffer size. It's applied only this case. Default value is 1024x4.
    * initialAcceptCount : Amount of pre-create acceptor. Default valud is 1024.
  * Note
    * The listen operation would start, when [FunctionReferenceEng#Open Open] method is called.
    * If you want to accept, you have to call `AddAcceptor` first then call [FunctionReferenceEng#Open Open]. 

== Open ==

  * Description
    * Start listen, start worker thread and so on.
  * Parameter
    * config
      * `Receive_Buffer_Len` : The maximum receive buffer size. It is applied globally.
      * `Worker_Thread_Count` : If you assign 0, the count is cpu*2.
      * `Send_Mode` : Either send immediately(DIRECT_SEND) or cyclically(INTERVAL_SEND).
      * `Interval_Send_Term` : The term which for interval_send and detecting socket close. The unit is millisecond and the recommend value is 20.
  * Note
    * You have to call [FunctionReferenceEng#Create Create] before this method.

== Prepare Message Block ==

  * Description
    * Allocate `MessageBlock` in `MessageBlockPool` in advance.
  * Parameter
    * bufferSize : buffer size
    * count :  buffer size
  * Note
    * We use `MessageBlock` for receive packet. The `MessageBlock` is from `MessageBlockPool`. This method is sort of pre-allocation.

== Prepare Memory Block ==

  * Description
    * Allocate `MemoryObject` in `MemoryPool` in advance.
  * Parameter : [FunctionReferenceEng#Prepare_Message_Block PrepareMessageBlock]

= Operation method =

  * Note
    * These methods are thread-safe. You can call any threads.

== Connect ==

  * Description
    * Connect to server
  * Parameter
    * See also [FunctionReferenceEng#Add_Acceptor AddAcceptor]
  * Note
    * [FunctionReferenceEng#Open Open] method must be called before.
    * Since it succeed to connect server, you will be get eMH_Establish message through [FunctionReferenceEng#Pop_Message PopMessage].
    * If there is no listen in the specific address and port, you can't receive any message. For that you can use [FunctionReferenceEng#Try_Connect TryConnect] method.

== Pop Message ==

  * Description
    * Get messages such as accept, connect, close and read
  * Parameter
    * queueId : It must be same as either [FunctionReferenceEng#Add_Acceptor AddAcceptor] or [FunctionReferenceEng#Connect Connect] methods' queueId parameter.
    * block : not allocated output block
    * timeout : wait time, if there is no block. -1 means infinite.
  * Note
    * Command block and Payload block make a message like linked list
    * [FunctionReferenceEng#PopAllMessage PopAllMessage] is the better for performance

== Pop All Message ==

  * Description
    * It's similar to [FunctionReferenceEng#Pop_Message PopMessage]. But gets whole messages in the queue.
  * Parameter
    * Same as [FunctionReferenceEng#Pop_Message PopMessage]
  * Note
    * It gets whole messages in the queue. So you have to process all messages during while loop.
    * It's definitely good for performance due to reduce Context swiching.

== Allocate Block ==

  * Description
    * Be allocated from `MessageBlockPool`

== Send Request ==

  * Description
    * Send packet 
  * Parameter
    * streamId : MessagePostee.streamId from [FunctionReferenceEng#Pop_Message PopMessage] method
    * You can select either `ACE_Message_Block` or `(char* buffer, int len)`
    * copy_block : If it's true, copy the block(or buffer) inside the function. False is good for performance, because it would decrease memory copy.
  * Note
    * The block(or buffer) will be free, when send is completed.

== Send Reserve ==

  * Description
    * Send packet after a certain delay 

== Close Stream ==

  * Note
    * Gracefull socket close

== Close Receive Stream ==

  * Note
    * Close only receive stream like closesocket(SD_RECEIVE)
    * [FunctionReferenceEng#Close_Stream CloseStream] is recommended rather than this.

== Pulse ==

  * Description
    * Wake up [FunctionReferenceEng#Pop_Message PopMessage] thread

== Push Custom Message == 

  * Description 
    * Insert user define block to queue
    * The message type is eMH_Custom.
  * Note
    * When you want to give a signal to packet parsing thread([FunctionReferenceEng#Pop_Message PopMessage] thread)

== Try Connect == 
  * Description
    * Test connect, whether there is a listen or not.
  * Note
    * It's only for test. If you want to communicate with peer after connect, you have to use [FunctionReferenceEng#Connect Connect] method.