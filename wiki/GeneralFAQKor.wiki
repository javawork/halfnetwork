#summary FAQ(Korean)

= 빌드 =
----
  Q. 링크에러가 발생합니다. 

  A. 프로젝트 설정의 아래 3가지 사항을 체크해보시기 바랍니다.
    * 일반 -> 문자집합(유니코드/멀티바이트)
    * C/C++ -> 코드 생성 -> 런타임 라이브러리
    * C/C++ -> 전처리기에 ACE_AS_STATIC_LIBS이 선언되어 있는지
----
  Q. MFC에서 사용하고 싶습니다.

  A. MFC를 위해 따로 빌드할 필요 없습니다. ACE의 config.h에 #define ACE_HAS_MFC 1 를 추가하지 않으셔야 합니다.
----

= 사용법 =

----
  Q. `NetworkInstance`->`PopMessage`(queue_id, &block, -1) 에서 진행이 되지 않습니다.

  A. `PopMessage`() 함수의 3번째 인자는 `MessageBlock`을 꺼내러 들어가서 메세지가 없을경우 얼마나 대기할지를 설정하는 인자입니다. 30은 30ms를 대기, 100은 100ms를 대기하고, -1은 메세지가 들어올때까지 대기합니다. 즉, -1을 넣으면 블럭될 수 있습니다.
----
  Q. `PopMessage`에 대기시간을 -1로 넣고도 주기적으로 깨어나게 하는 방법은 없습니까?

  A. 초기화할때 `AddTimer`를 설정해서 주기적으로 깨어나게 할수도 있고, 다른 스레드에서 `PushCustomMessage`를 호출해서 깨어나게 할수도 있습니다. 주기적으로 어떤일을 처리해야 한다면 `AddTimer`를 사용하시고, 어떤일이 발생했을때만 깨어나서 일을 처리하게 하고 싶으시면 `PushCustomMessage`를 사용하는 것을 추천합니다.
----
  Q. 라이브러리에서 자체적으로 패킷을 주고 받는게 있나요?

  A. `HalfNetwork`은 자체적으로 어떤 패킷도 보내지 않습니다. `SendRequest`의 인자로 넣어진 버퍼만 송신합니다.
----
  Q. 라이브러리에서 자체적으로 암호화/복호화를 수행하나요?

  A. 아니요. 현재는 암호화/복호화에 관련된 기능을 제공하지 않습니다.
----
  Q. TCP 패킷의 특성중 하나인 패킷이 뭉치거나 잘라지는 현상을 라이브러리에서 해결해 주나요? 
 
  A. 아니요. 이것을 해결하기 위해서는 자체적인 헤더를 가져야하는데, `HalfNetwork`은 패킷에 헤더를 붙이지 않기 때문에 이것을 해결해주지 못합니다. 어플리케이션에서 이 현상을 고려해서 코드를 작성해야 합니다.
----
  Q. 메소드들은 Thread-Safe 한가요?

  A. FunctionReferenceKor 문서에 Thread-Safe한 메소드와 그렇지 않은 것들이 명시되어 있습니다. 대체적으로 초기화 관련된 것들은 Thread-Safe 하지않고, 초기화 후에 사용하는 메소드들은 Thread-Safe 합니다. 
----
  Q. 사용되는 StreamID는 unique 한가요?

  A. 그렇습니다. StreamID는 0~4096 까지 순차적으로 사용되고 다시 순환됩니다.
----
  Q. 접속 개체수 제한을 늘리고 싶습니다.

  A. Proactor를 사용하실때는 `ProactorService.h`의 `Max_ProactorService`, Reactor를 사용하실때는 `ReactorService.h`의 `Max_ReactorService`를 수정하시면 됩니다.
----
  Q. `SystemConfig`  각 변수들의 의미를 알고 싶습니다.

  A. 각 변수들의 의미는 아래와 같습니다.
    * `Receive_Buffer_Len` : Receive 버퍼의 최대 크기.  기본값은 1024x4 입니다. 너무 작게 설정하면 큰 패킷을 받을때 여러번 Receive를 하게되서 성능이 저하되고 너무 크게 설정하면 메모리가 낭비됩니다. 프로젝트에서 사용하는 가장 큰 패킷의 크기로 설정하시는게 좋습니다.
    * `Worker_Thread_Count` : Network worker 스레드의 개수. 0으로 설정하면 cpu개수x2로 설정됩니다.
    * `Send_Mode` : 패킷 전송 요청이 들어오면 바로 보낼것 인지(eSM_Direct) 모아서 보낼 것인지(eSM_Interval)를 결정합니다. 작은 패킷전송 요청이 잦은 경우(초당 수십~수백)에는 모아서 보내는 것을 추천합니다.
    * `Interval_Send_Term` : 모아서 보내는 모드일 경우(eSM_Interval) 모아서 보내는 시간을 결정합니다. 밀리세컨드 단위이고 기본값은 20ms 입니다. 
    * `ZombieConnectionTerm` : 일정시간동안 패킷을 보내지 않으면 해당 세션을 끊어주는 기능을 활성화합니다. 역시 밀리세컨드 단위이고 0으로 넣어주면 해당 기능을 사용하지 않습니다.
----
  Q. 종료시에 호출해야하는 메소드의 순서는?

  A. 아래의 순서로 하시면 됩니다.
    * `NetworkInstance->Pulse();` // `PopMessage`를 깨어나게 합니다.
    * `NetworkInstance->Close();` // Accept, Receive 등의 동작들을 중지 합니다.
    * `NetworkInstance->Destroy();` // 객체들을 소멸시킵니다.
----