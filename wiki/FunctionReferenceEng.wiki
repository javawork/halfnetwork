#summary Public function reference on NetworkFacade(English)

= Initialization methods =

  * Note
    * Initialization methods aren't thread safe. It should be called only before start service.

== Create ==

  * Description
    * Decide event model(Proactor/Reactor)
  * Note
    * On Windows, Proactor is the best choice for performance. On Linux, Reactor is the one.

== Add Acceptor ==

  * Description
    * Prepare for Listen 
    * Add an accept port
  * Parameter
    * acceptIp : In case you want to accept only specific ip. Otherwise assign NULL.
    * port : listen port
    * queueId : It must be same as [FunctionReferenceEng#Pop_Message PopMessage] (or [FunctionReferenceEng#Pop_All_Message PopAllMessage]) queueId parameter.
    * receiveBufferSize : The maximum receive buffer size. It's applied only this case. Default value is 1024x4.
    * initialAcceptCount : Amount of pre-create acceptor. Default valud is 1024.
  * Note
    * The listen operation would start, when [FunctionReferenceEng#Open Open] method is called.
    * If you want to accept, you have to call `AddAcceptor` first then call [FunctionReferenceEng#Open Open]. 

== Open ==

  * Description
    * Start listen, start worker thread and so on.
  * Parameter
    * config
      * `Receive_Buffer_Len` : The maximum receive buffer size. It is applied globally.
      * `Worker_Thread_Count` : If you assign 0, the count is cpu*2.
      * `Send_Mode` : Either send immediately(DIRECT_SEND) or cyclically(INTERVAL_SEND).
      * `Interval_Send_Term` : The term which for interval_send and detecting socket close. The unit is millisecond and the recommend value is 20.
  * Note
    * You have to call [FunctionReferenceEng#Create Create] before this method.

== Prepare Message Block ==

  * Description
    * Allocate `MessageBlock` in `MessageBlockPool` in advance.
  * Parameter
    * bufferSize : buffer size
    * count :  buffer size
  * Note
    * We use `MessageBlock` for receive packet. The `MessageBlock` is from `MessageBlockPool`. This method is sort of pre-allocation.

== Prepare Memory Block ==

  * Description
    * Allocate `MemoryObject` in `MemoryPool` in advance.
  * Parameter : [FunctionReferenceEng#Prepare_Message_Block PrepareMessageBlock]

= Operation method =

  * Note
    * These methods are thread-safe. You can call any threads.

== Connect ==

  * Description
    * Connect to server
  * Parameter
    * See also [FunctionReferenceEng#Add_Acceptor AddAcceptor]
  * Note
    * [FunctionReferenceEng#Open Open] method must be called before.
    * Since it succeed to connect server, you will be get eMH_Establish message through [FunctionReferenceEng#Pop_Message PopMessage].
    * If there is no listen in the specific address and port, you can't receive any message. For that you can use [FunctionReferenceEng#Try_Connect TryConnect] method.

== Pop Message ==

  * Description
    * Get messages such as accept, connect, close and read
  * Parameter
    * queueId : It must be same as either [FunctionReferenceEng#Add_Acceptor AddAcceptor] or [FunctionReferenceEng#Connect Connect] methods' queueId parameter.
    * block : not allocated output block
    * timeout : wait time, if there is no block. -1 means infinite.
  * Note
    * Command block and Payload block make a message like linked list
    * [FunctionReferenceEng#PopAllMessage PopAllMessage] is the better for performance

== Pop All Message ==

  * Description
    * It's similar to [FunctionReferenceEng#Pop_Message PopMessage]. But gets whole messages in the queue.
  * Parameter
    * Same as [FunctionReferenceEng#Pop_Message PopMessage]
  * Note
    * It gets whole messages in the queue. So you have to process all messages during while loop.
    * It's definitely good for performance due to reduce Context swiching.

== Allocate Block ==

  * Description
    * Be allocated from `MessageBlockPool`

== Send Request ==

  * Description
    * Send packet 
  * Parameter
    * streamId : [FunctionReferenceEng#Pop_Message PopMessage]에서 넘어온 MessagePostee.streamId 값을 넣어주면 됩니다.
    * block 혹은 buffer, length : block 혹은 buffer를 선택적으로 사용할 수 있습니다.
    * copy_block : 인자로 넣어준 block을 라이브러리가 복사해서 사용할 것인지 설정해줍니다. false로 사용하는 것이 성능에는 좋습니다.
  * Note
    * 인자로 넣어준 block 혹은 버퍼는 send가 완료되면 라이브러리안에서 해제됩니다.

== Send Reserve ==

  * Description
    * 일정 시간(millisecond) 후에 패킷을 보낼 것을 예약합니다
  * Note
    * 일반 send와 같은 queue에 관리되기 때문에 일반 send가 너무 많아서 예약된 send가 delay되는 경우는 없습니다.

== Close Stream ==

  * Note
    * 나중에는 closesocket을 호출하게 되지만 중간 과정은 gracefull close를 구현하고 있습니다.

== Close Receive Stream ==

  * Note
    * 받기스트림만 종료합니다. closesocket(SD_RECEIVE) 입니다.
    * 일반적으로 [FunctionReferenceEng#Close_Stream CloseStream]을 호출하는 것을 추천합니다.

== Pulse ==

  * Description
    * 대기하고 있는 [FunctionReferenceEng#Pop_Message PopMessage]에 신호를 주어서 깨웁니다.
  * Note
    * 종료시에나 [FunctionReferenceEng#Pop_Message PopMessage]를 처리하는 스레드에 어떤 작업을 처리하도록 요청할때 사용할 수 있습니다.

== Push Custom Message == 

  * Description 
    * 사용자 정의 블럭 하나를 Queue에 넣어줍니다.
    * [FunctionReferenceEng#Pop_Message PopMessage]에서 eMH_Custom 타입으로 받아서 처리할 수 있습니다.
  * Note
    * 어떤 작업을 패킷처리 스레드에서 처리하도록 하고 싶을때 사용하면 좋습니다. 

== Try Connect == 
  * Description
    * 해당 주소와 포트에서 listen하고 있는지 체크합니다.
  * Note
    * 이 메소드는 체크만 하는데 사용해야하고 이후 메세지를 주고 받고 싶다면 [FunctionReferenceEng#Connect Connect]메소드를 사용해야 합니다.